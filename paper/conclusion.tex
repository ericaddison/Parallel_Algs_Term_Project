The Fast Fourier Transform implemented in $T(N) = \mathcal{O}(N^2)$ is not tenable for large order transforms. From the above graphs it is clear that as the number of input elements grows, a better solution is needed. We have discussed two algorithms that implement the FFT. The first is the recursive solution first (re-)discovered by Cooley-Tukey. With some manipulation and bit-twiddling, the recursive algorithm can be transformed into an iterative one.

We focused on two ways to parallelize the FFT algorithm. First by using the C/C++ extension cilk, and then by implementing it on a GPU. Overall, the Cuda algorithm beat any other algorithm by several orders of magnitude. However, since the GPU is run as a device attached to the main host CPU, it suffers from the time lag needed to transfer data to and from the GPU. When processing vectors of size greater than $2^{13}$ elements, Cuda's performance even with this penalty beats the Python-Numpy implementation. 

On the other hand, Cilk was a very good contender in terms of performance as the number of elements increased. However, from our results it is obvious that the overhead of parallelism is not worth it for smaller input vectors since performance lagged as compared to the traditional C++ algorithms. For inputs with $N>2^{14}$, however, the Cilk implementations outperform the sequential algorithms. 